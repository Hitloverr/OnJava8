
- 构造器 和 GC
- 构造器名称与类名相同，在初始化过程中自动调用构造器方法。
  - 在java中，对象的创建和初始化是统一的概念，二者不可分割。


- 方法重载，区分方式是参数列表。

- 基本类型可以自动从较小的类型转为较大的类型，这与重载结合的时候，就很奇怪了。
如果传入的参数类型大于方法期望接收的参数类型，必须首先做下转换，不然就会报错。

  -不能根据返回值区分重载。

- this：当前对象的引用，只用在一些必须显示使用当前对象引用的特殊场合。。比如，用在return语句中返回当前对象的引用。
  - 在构造器中调用构造器。

- static：类似全局变量 全局方法。
- 垃圾回收器。


它的工作原理 “假定” 是这样的：当垃圾回收器准备回收对象的内存时，首先会调
用其 finalize() 方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的
内存。所以如果你打算使用 finalize() ，就能在垃圾回收时做一些重要的清理工作。
finalize() 是一个潜在的编程陷阱，因为一些程序员（尤其是 C++ 程序员）会一开
始把它误认为是 C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必
要明确区分一下：在 C++ 中，对象总是被销毁的（在一个 bug-free 的程序中），而在
Java 中，对象并非总是被垃圾回收，或者换句话说：
1. 对象可能不被垃圾回收。
2. 垃圾回收不等同于析构。

这意味着在你不再需要某个对象之前，如果必须执行某些动作，你得自己去做。

也许你会发现，只要程序没有濒临内存用完的那一刻，对象占用的空间就总也得不
到释放。如果程序执行结束，而垃圾回收器一直没有释放你创建的任何对象的内存，则
当程序退出时，那些资源会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本
身也有开销，要是不使用它，那就不用支付这部分开销了


3. 垃圾回收只与内存有关


finalize方法只有一种特殊情况：通过某种创建对象方式之外的方式为对象分配了存储空间。
比如本地方法，调用c的malloc函数来分配存储空间，除非调用free函数。你需要在finalize方法里调用本地方法调用它。


- 无论是垃圾回收还是终结，都不保证一定发生。
一种有用的方式是发现程序中的bug
```java


class Book {
boolean checkedOut = false;
Book(boolean checkOut) {
checkedOut = checkOut;
}
void checkIn() {
checkedOut = false;
}
@Override
protected void finalize() throws Throwable {
if (checkedOut) {
System.out.println("Error: checked out");
}
// Normally, you'll also do this:
// super.finalize(); // Call the base-class version
}
}

public class TerminationCondition {
  public static void main(String[] args) {
    Book novel = new Book(true);
// Proper cleanup:
    novel.checkIn();
// Drop the reference, forget to clean up:
    new Book(true);
// Force garbage collection & finalization:
    System.gc();
    new Nap(1); // One second delay
  }
}
输出：
        Error: checked out

本例的终结条件是：所有的 Book 对象在被垃圾回收之前必须被登记。但在 main()
方法中，有一本书没有登记。要是没有 finalize() 方法来验证终结条件，将会很难发
现这个 bug。
```

# 垃圾回收器如何工作
java中的堆指针只是简单地移动到尚未分配的区域。这使得java分配对象也很快。
垃圾回收器能很大程度上保证堆中的对象紧凑排列。

1. 引用计数法：循环引用就GG
2. 从根源于栈或者静态存储区的引用中遍历，标记所有活的对象。
- 两块内存区域，复制。young gc
- 标记-清扫
- 标记-复制整理


# 即时编译器--> 直接变成机器码，执行次数越多，速度越快

# 成员初始化
局部变量没有默认初始值，但是成员变量是有的。

初始化可以直接赋值，可以通过调用方法来赋值，可以构造器初始化。

在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义
之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。

# 静态数据的初始化
静态初始化只有在必要时刻才会进行。如果不创建 Table 对象，也
不引用 Table.bowl1 或 Table.bowl2，那么静态的 Bowl 类对象 bowl1 和 bowl2 永
远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。
此后，静态对象不会再次被初始化。
初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对
象，从输出中可以看出。要执行 main() 方法，必须加载 StaticInitialization 类，它
的静态属性 table 和 cupboard 随后被初始化，这会导致它们对应的类也被加载，而
由于它们都包含静态的 Bowl 对象，所以 Bowl 类也会被加载。因此，在这个特殊的程
序中，所有的类都会在 main() 方法之前被加载。实际情况通常并非如此，因为在典型
的程序中，不会像本例中所示的那样，将所有事物通过 static 联系起来。

概括一下创建对象的过程，假设有个名为 Dog 的类：
1. 即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次
   创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释器必
   须在类路径中查找，以定位 Dog.class。
2. 当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初
   始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时初始
   化一次。
3. 当用 new Dog() 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。
4. 分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为
   默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。
5. 执行所有出现在字段定义处的初始化动作。
6. 执行构造器。你将会在 “复用” 这一章看到，这可能会牵涉到很多动作，尤其当涉
   及继承的时候

# 显示的静态初始化
public class Spoon {
static int i;
static {
i = 47;
}
}
# 非静态初始化
{

}
代码块，执行顺序是在构造器执行之前

# 数组初始化
动态初始化，静态初始化。也可以{} 初始化数组

# 可变参数
(Object... args)
可变参数 + 方法重载，可能导致在调用没有参数的方法的时候，编译报错。

# 枚举类型
enum toString() ordinal() values()

在很大程度上你可以将 enum 当作其他任何类。事
实上，enum 确实是类，并且具有自己的方法。

# 总结
