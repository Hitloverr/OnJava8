- 重构的过程中如何保证原来使用你代码的那些人不会骂你？可变的和不变的。

# 包的概念
1. 命名空间与import，默认包。
2. 编译单元，public 类 与文件名的关系。
3. 其他语言一般是编译->.obj,再链接成exe；java：可运行程序是一组.class文件，打包压缩成jar文件，java解释器负责查找、加载和解释这些文件。
4. 包名规范都是小写，中间的单词也是这样子。

- package名称是类创建者反顺序的域名，将所有文件放在一个子目录下。java加载class文件的时候，从CLASSPAH找，将包名替换成目录名，比如com.foo 就找classPath:/com/foo路径。
  - 举例，域名mindview.com，创建一个名为simple的类库。package名就是com.mindview.simple,在电脑上路径是D:\java\com\mindview\simple,D:\java在classpath下。
  - 但是在使用jar文件时，classpath必须写清楚实际名称，c:flavors\garp.jar，而不能只是c:flavors

- 冲突，不同包下有了同名类。那你必须明确指明。
- 条件编译还有其他的用途。调试是一个很常见的用途，调试功能在开发过程
  中是开启的，在发布的产品中是禁用的。可以通过改变导入的 package 来实现这一目
  的，修改的方法是将程序中的代码从调试版改为发布版。这个技术可用于任何种类的条
  件代码

## 使用包的忠告
- 遵守 “包名对应目录路径” 的规则
- 编译过的代码通常位于与源代码的不同目录中。这是很多工程的标准，而且
  集成开发环境（IDE）通常会自动为我们做这些。必须保证 JVM 通过 CLASSPATH 能
  找到编译后的代码。

## 访问权限修饰符
1. 使成员成为 public。那么无论是谁，无论在哪，都可以访问它。
2. 赋予成员默认包访问权限，不用加任何访问修饰符，然后将其他类放在相同的包
   内。这样，其他类就可以访问该成员。
3. 在 “复用” 这一章你将看到，继承的类既可以访问 public 成员，也可以访问 protected 成员（但不能访问 private 成员）。只有当两个类处于同一个包内，它才
   可以访问包访问权限的成员。但现在不用担心继承和 protected。
4. 提供访问器（accessor）和修改器（mutator）方法（有时也称为 “get/set” 方法），
   从而读取和改变值

在相同的目录中且没有给自己设定
明确的包名。Java 把这样的文件看作是隶属于该目录的默认包中，因此它们为该目录
中所有的其他文件都提供了包访问权限。

记住，使用类的客户端程序员无法
访问包访问权限成员。这样做很好，因为默认访问权限是一种我们常用的权限（同时也
是一种在忘记添加任何访问权限时自动得到的权限）。因此，通常考虑的是把哪些成员
声明成 public 供客户端程序员使用。所以，最初不常使用关键字 private，因为程序没
有它也可以照常工作。然而，使用 private 是非常重要的，尤其是在多线程环境中。

private 的用武之地：控制如何创建对象，防止别人直接访问某个特定
的构造器（或全部构造器）。

在一个具有包访问权限的类中定义一个 public 的构造器并不能真的使这个
构造器成为 public，在声明的时候就应该标记为编译时错误

# 接口和实现

接口和实现相互分离，划分边界。

为了清晰起见，你可以采用一种创建类的风格：public 成员放在类的开头，接着
是 protected 成员，包访问权限成员，最后是 private 成员。这么做的好处是类的使
用者可以从头读起，首先会看到对他们而言最重要的部分（public 成员，因为可以从文
件外访问它们），直到遇到非 public 成员时停止阅读，下面就是内部实现了

1. 每个编译单元（即每个文件）中只能有一个 public 类。这表示，每个编译单元有
   一个公共的接口用 public 类表示。该接口可以包含许多支持包访问权限的类。一
   旦一个编译单元中出现一个以上的 public 类，编译就会报错。
2. public 类的名称必须与含有该编译单元的文件名相同，包括大小写。所以
   对于 Widget 来说，文件名必须是 Widget.java，不能是 widget.java 或
   WIDGET.java。再次强调，如果名字不匹配，编译器会报错。
3. 虽然不是很常见，但是编译单元内没有 public 类也是可能的。这时可以随意命名
   文件（尽管随意命名会让代码的阅读者和维护者感到困惑）。

对于类的访问权限只有两种选择：包访问权限或者 public

# 总结
控制成员访问权限有两个原因。第一个原因是使用户不要接触他们不该接触的部
分，这部分对于类内部来说是必要的，但是不属于客户端程序员所需接口的一部分。因
此将方法和属性声明为 private 对于客户端程序员来说是一种服务，可以让他们清楚
地看到什么是重要的，什么可以忽略。这可以简化他们对类的理解。

第二个也是最重要的原因是为了让类库设计者更改类内部的工作方式，而不用担
心会影响到客户端程序员。比如最初以某种方式创建一个类，随后发现如果更改代码结
构可以极大地提高运行速度。如果接口与实现被明确地隔离和保护，你可以实现这一目
的，而不必强制客户端程序员重新编写代码。访问权限控制确保客户端程序员不会依赖
某个类的底层实现的任何部分。